!function ( t, e ) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define( e ) : ( t = "undefined" != typeof globalThis ? globalThis : t || self ).io = e() }( this, function () { "use strict"; function c ( t ) { return ( c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function ( t ) { return typeof t } : function ( t ) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t } )( t ) } function s ( t, e ) { if ( !( t instanceof e ) ) throw new TypeError( "Cannot call a class as a function" ) } function r ( t, e ) { for ( var n = 0; n < e.length; n++ ) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && ( r.writable = !0 ), Object.defineProperty( t, r.key, r ) } } function a ( t, e, n ) { e && r( t.prototype, e ), n && r( t, n ) } function u () { return ( u = Object.assign || function ( t ) { for ( var e = 1; e < arguments.length; e++ ) { var n, r = arguments[e]; for ( n in r ) Object.prototype.hasOwnProperty.call( r, n ) && ( t[n] = r[n] ) } return t } ).apply( this, arguments ) } function h ( t, e ) { if ( "function" != typeof e && null !== e ) throw new TypeError( "Super expression must either be null or a function" ); t.prototype = Object.create( e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } } ), e && n( t, e ) } function f ( t ) { return ( f = Object.setPrototypeOf ? Object.getPrototypeOf : function ( t ) { return t.__proto__ || Object.getPrototypeOf( t ) } )( t ) } function n ( t, e ) { return ( n = Object.setPrototypeOf || function ( t, e ) { return t.__proto__ = e, t } )( t, e ) } function l ( t ) { if ( void 0 === t ) throw new ReferenceError( "this hasn't been initialised - super() hasn't been called" ); return t } function p ( n ) { var r = function () { if ( "undefined" == typeof Reflect || !Reflect.construct ) return !1; if ( Reflect.construct.sham ) return !1; if ( "function" == typeof Proxy ) return !0; try { return Boolean.prototype.valueOf.call( Reflect.construct( Boolean, [], function () { } ) ), !0 } catch ( t ) { return !1 } }(); return function () { var t, e = f( n ), e = ( t = r ? ( t = f( this ).constructor, Reflect.construct( e, arguments, t ) ) : e.apply( this, arguments ), this ); if ( t && ( "object" == typeof t || "function" == typeof t ) ) return t; if ( void 0 !== t ) throw new TypeError( "Derived constructors may only return object or undefined" ); return l( e ) } } function d ( t, e, n ) { return ( d = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function ( t, e, n ) { var t = function ( t, e ) { for ( ; !Object.prototype.hasOwnProperty.call( t, e ) && null !== ( t = f( t ) ); ); return t }( t, e ); if ( t ) return t = Object.getOwnPropertyDescriptor( t, e ), t.get ? t.get.call( n ) : t.value } )( t, e, n || t ) } function I ( t, e ) { ( null == e || e > t.length ) && ( e = t.length ); for ( var n = 0, r = new Array( e ); n < e; n++ )r[n] = t[n]; return r } function q ( t, e ) { var n, r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if ( !r ) { if ( Array.isArray( t ) || ( r = function ( t, e ) { if ( t ) { if ( "string" == typeof t ) return I( t, e ); var n = Object.prototype.toString.call( t ).slice( 8, -1 ); return "Map" === ( n = "Object" === n && t.constructor ? t.constructor.name : n ) || "Set" === n ? Array.from( t ) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test( n ) ? I( t, e ) : void 0 } }( t ) ) || e && t && "number" == typeof t.length ) return r && ( t = r ), n = 0, { s: e = function () { }, n: function () { return n >= t.length ? { done: !0 } : { done: !1, value: t[n++] } }, e: function ( t ) { throw t }, f: e }; throw new TypeError( "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method." ) } var o, i = !0, s = !1; return { s: function () { r = r.call( t ) }, n: function () { var t = r.next(); return i = t.done, t }, e: function ( t ) { s = !0, o = t }, f: function () { try { i || null == r.return || r.return() } finally { if ( s ) throw o } } } } var U = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, D = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"], i = function ( t ) { for ( var r, e = t, n = t.indexOf( "[" ), o = t.indexOf( "]" ), i = ( -1 != n && -1 != o && ( t = t.substring( 0, n ) + t.substring( n, o ).replace( /:/g, ";" ) + t.substring( o, t.length ) ), U.exec( t || "" ) ), s = {}, a = 14; a--; )s[D[a]] = i[a] || ""; return -1 != n && -1 != o && ( s.source = e, s.host = s.host.substring( 1, s.host.length - 1 ).replace( /;/g, ":" ), s.authority = s.authority.replace( "[", "" ).replace( "]", "" ).replace( /;/g, ":" ), s.ipv6uri = !0 ), s.pathNames = function ( t ) { var e = t.replace( /\/{2,9}/g, "/" ).split( "/" ); "/" != t.substr( 0, 1 ) && 0 !== t.length || e.splice( 0, 1 ); "/" == t.substr( t.length - 1, 1 ) && e.splice( e.length - 1, 1 ); return e }( s.path ), s.queryKey = ( t = s.query, r = {}, t.replace( /(?:^|&)([^&=]*)=?([^&]*)/g, function ( t, e, n ) { e && ( r[e] = n ) } ), r ), s }; var e = { exports: {} }; try { e.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest } catch ( t ) { e.exports = !1 } var H = e.exports, o = "undefined" != typeof self ? self : "undefined" != typeof window ? window : Function( "return this" )(); function F ( t ) { t = t.xdomain; try { if ( "undefined" != typeof XMLHttpRequest && ( !t || H ) ) return new XMLHttpRequest } catch ( t ) { } if ( !t ) try { return new o[["Active"].concat( "Object" ).join( "X" )]( "Microsoft.XMLHTTP" ) } catch ( t ) { } } function M ( n ) { for ( var t = arguments.length, e = new Array( 1 < t ? t - 1 : 0 ), r = 1; r < t; r++ )e[r - 1] = arguments[r]; return e.reduce( function ( t, e ) { return n.hasOwnProperty( e ) && ( t[e] = n[e] ), t }, {} ) } var V = setTimeout, K = clearTimeout; function y ( t, e ) { e.useNativeTimers ? ( t.setTimeoutFn = V.bind( o ), t.clearTimeoutFn = K.bind( o ) ) : ( t.setTimeoutFn = setTimeout.bind( o ), t.clearTimeoutFn = clearTimeout.bind( o ) ) } var v = m; function m ( t ) { if ( t ) { var e, n = t; for ( e in m.prototype ) n[e] = m.prototype[e]; return n } } m.prototype.on = m.prototype.addEventListener = function ( t, e ) { return this._callbacks = this._callbacks || {}, ( this._callbacks["$" + t] = this._callbacks["$" + t] || [] ).push( e ), this }, m.prototype.once = function ( t, e ) { function n () { this.off( t, n ), e.apply( this, arguments ) } return n.fn = e, this.on( t, n ), this }, m.prototype.off = m.prototype.removeListener = m.prototype.removeAllListeners = m.prototype.removeEventListener = function ( t, e ) { if ( this._callbacks = this._callbacks || {}, 0 == arguments.length ) return this._callbacks = {}, this; var n, r = this._callbacks["$" + t]; if ( !r ) return this; if ( 1 == arguments.length ) return delete this._callbacks["$" + t], this; for ( var o = 0; o < r.length; o++ )if ( ( n = r[o] ) === e || n.fn === e ) { r.splice( o, 1 ); break } return 0 === r.length && delete this._callbacks["$" + t], this }, m.prototype.emitReserved = m.prototype.emit = function ( t ) { this._callbacks = this._callbacks || {}; for ( var e = new Array( arguments.length - 1 ), n = this._callbacks["$" + t], r = 1; r < arguments.length; r++ )e[r - 1] = arguments[r]; if ( n ) for ( var r = 0, o = ( n = n.slice( 0 ) ).length; r < o; ++r )n[r].apply( this, e ); return this }, m.prototype.listeners = function ( t ) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || [] }, m.prototype.hasListeners = function ( t ) { return !!this.listeners( t ).length }; for ( var g = Object.create( null ), k = ( g.open = "0", g.close = "1", g.ping = "2", g.pong = "3", g.message = "4", g.upgrade = "5", g.noop = "6", Object.create( null ) ), Y = ( Object.keys( g ).forEach( function ( t ) { k[g[t]] = t } ), { type: "error", data: "parser error" } ), z = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === Object.prototype.toString.call( Blob ), $ = "function" == typeof ArrayBuffer, W = function ( t ) { return "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView( t ) : t && t.buffer instanceof ArrayBuffer }, J = function ( t, e, n ) { var r = t.type, t = t.data; return z && t instanceof Blob ? e ? n( t ) : X( t, n ) : $ && ( t instanceof ArrayBuffer || W( t ) ) ? e ? n( t ) : X( new Blob( [t] ), n ) : n( g[r] + ( t || "" ) ) }, X = function ( t, e ) { var n = new FileReader; return n.onload = function () { var t = n.result.split( "," )[1]; e( "b" + t ) }, n.readAsDataURL( t ) }, G = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", b = "undefined" == typeof Uint8Array ? [] : new Uint8Array( 256 ), t = 0; t < G.length; t++ )b[G.charCodeAt( t )] = t; function Q ( t, e ) { if ( "string" != typeof t ) return { type: "message", data: rt( t, e ) }; var n = t.charAt( 0 ); return "b" === n ? { type: "message", data: Z( t.substring( 1 ), e ) } : k[n] ? 1 < t.length ? { type: k[n], data: t.substring( 1 ) } : { type: k[n] } : Y } function Z ( t, e ) { var n; return nt ? ( n = et( t ), rt( n, e ) ) : { base64: !0, data: t } } var tt, et = function ( t ) { for ( var e, n, r, o, i = .75 * t.length, s = t.length, a = 0, i = ( "=" === t[t.length - 1] && ( i--, "=" === t[t.length - 2] && i-- ), new ArrayBuffer( i ) ), c = new Uint8Array( i ), u = 0; u < s; u += 4 )e = b[t.charCodeAt( u )], n = b[t.charCodeAt( u + 1 )], r = b[t.charCodeAt( u + 2 )], o = b[t.charCodeAt( u + 3 )], c[a++] = e << 2 | n >> 4, c[a++] = ( 15 & n ) << 4 | r >> 2, c[a++] = ( 3 & r ) << 6 | 63 & o; return i }, nt = "function" == typeof ArrayBuffer, rt = function ( t, e ) { return "blob" === e && t instanceof ArrayBuffer ? new Blob( [t] ) : t }, ot = String.fromCharCode( 30 ), it = function () { h( r, v ); var n = p( r ); function r ( t ) { var e; return s( this, r ), ( e = n.call( this ) ).writable = !1, y( l( e ), t ), e.opts = t, e.query = t.query, e.readyState = "", e.socket = t.socket, e } return a( r, [{ key: "onError", value: function ( t, e ) { t = new Error( t ); return t.type = "TransportError", t.description = e, d( f( r.prototype ), "emit", this ).call( this, "error", t ), this } }, { key: "open", value: function () { return "closed" !== this.readyState && "" !== this.readyState || ( this.readyState = "opening", this.doOpen() ), this } }, { key: "close", value: function () { return "opening" !== this.readyState && "open" !== this.readyState || ( this.doClose(), this.onClose() ), this } }, { key: "send", value: function ( t ) { "open" === this.readyState && this.write( t ) } }, { key: "onOpen", value: function () { this.readyState = "open", this.writable = !0, d( f( r.prototype ), "emit", this ).call( this, "open" ) } }, { key: "onData", value: function ( t ) { t = Q( t, this.socket.binaryType ); this.onPacket( t ) } }, { key: "onPacket", value: function ( t ) { d( f( r.prototype ), "emit", this ).call( this, "packet", t ) } }, { key: "onClose", value: function () { this.readyState = "closed", d( f( r.prototype ), "emit", this ).call( this, "close" ) } }] ), r }(), st = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split( "" ), w = 64, at = {}, ct = 0, A = 0; function C ( t ) { for ( var e = ""; e = st[t % w] + e, 0 < ( t = Math.floor( t / w ) ); ); return e } function _ () { var t = C( +new Date ); return t !== tt ? ( ct = 0, tt = t ) : t + "." + C( ct++ ) } for ( ; A < w; A++ )at[st[A]] = A; _.encode = C, _.decode = function ( t ) { var e = 0; for ( A = 0; A < t.length; A++ )e = e * w + at[t.charAt( A )]; return e }; var ut = _, E = { encode: function ( t ) { var e, n = ""; for ( e in t ) t.hasOwnProperty( e ) && ( n.length && ( n += "&" ), n += encodeURIComponent( e ) + "=" + encodeURIComponent( t[e] ) ); return n }, decode: function ( t ) { for ( var e = {}, n = t.split( "&" ), r = 0, o = n.length; r < o; r++ ) { var i = n[r].split( "=" ); e[decodeURIComponent( i[0] )] = decodeURIComponent( i[1] ) } return e } }, ht = function () { h( n, it ); var e = p( n ); function n () { var t; return s( this, n ), ( t = e.apply( this, arguments ) ).polling = !1, t } return a( n, [{ key: "name", get: function () { return "polling" } }, { key: "doOpen", value: function () { this.poll() } }, { key: "pause", value: function ( t ) { function e () { r.readyState = "paused", t() } var n, r = this; this.readyState = "pausing"; this.polling || !this.writable ? ( n = 0, this.polling && ( n++, this.once( "pollComplete", function () { --n || e() } ) ), this.writable || ( n++, this.once( "drain", function () { --n || e() } ) ) ) : e() } }, { key: "poll", value: function () { this.polling = !0, this.doPoll(), this.emit( "poll" ) } }, { key: "onData", value: function ( t ) { var e = this; !function ( t, e ) { for ( var n = t.split( ot ), r = [], o = 0; o < n.length; o++ ) { var i = Q( n[o], e ); if ( r.push( i ), "error" === i.type ) break } return r }( t, this.socket.binaryType ).forEach( function ( t ) { if ( "opening" === e.readyState && "open" === t.type && e.onOpen(), "close" === t.type ) return e.onClose(), !1; e.onPacket( t ) } ), "closed" !== this.readyState && ( this.polling = !1, this.emit( "pollComplete" ), "open" === this.readyState && this.poll() ) } }, { key: "doClose", value: function () { function t () { e.write( [{ type: "close" }] ) } var e = this; "open" === this.readyState ? t() : this.once( "open", t ) } }, { key: "write", value: function ( t ) { var n, r, o, i, e = this; this.writable = !1, n = function ( t ) { e.doWrite( t, function () { e.writable = !0, e.emit( "drain" ) } ) }, r = ( t = t ).length, o = new Array( r ), i = 0, t.forEach( function ( t, e ) { J( t, !1, function ( t ) { o[e] = t, ++i === r && n( o.join( ot ) ) } ) } ) } }, { key: "uri", value: function () { var t = this.query || {}, e = this.opts.secure ? "https" : "http", n = "", t = ( !1 !== this.opts.timestampRequests && ( t[this.opts.timestampParam] = ut() ), this.supportsBinary || t.sid || ( t.b64 = 1 ), this.opts.port && ( "https" == e && 443 !== Number( this.opts.port ) || "http" == e && 80 !== Number( this.opts.port ) ) && ( n = ":" + this.opts.port ), E.encode( t ) ); return e + "://" + ( -1 !== this.opts.hostname.indexOf( ":" ) ? "[" + this.opts.hostname + "]" : this.opts.hostname ) + n + this.opts.path + ( t.length ? "?" + t : "" ) } }] ), n }(); function ft () { } var lt = null != new F( { xdomain: !1 } ).responseType, e = function () { h( i, ht ); var o = p( i ); function i ( t ) { s( this, i ), e = o.call( this, t ), "undefined" != typeof location && ( n = "https:" === location.protocol, r = ( r = location.port ) || ( n ? "443" : "80" ), e.xd = "undefined" != typeof location && t.hostname !== location.hostname || r !== t.port, e.xs = t.secure !== n ); var e, n, r = t && t.forceBase64; return e.supportsBinary = lt && !r, e } return a( i, [{ key: "request", value: function () { var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}; return u( t, { xd: this.xd, xs: this.xs }, this.opts ), new B( this.uri(), t ) } }, { key: "doWrite", value: function ( t, e ) { var n = this, t = this.request( { method: "POST", data: t } ); t.on( "success", e ), t.on( "error", function ( t ) { n.onError( "xhr post error", t ) } ) } }, { key: "doPoll", value: function () { var e = this, t = this.request(); t.on( "data", this.onData.bind( this ) ), t.on( "error", function ( t ) { e.onError( "xhr poll error", t ) } ), this.pollXhr = t } }] ), i }(), B = function () { h( o, v ); var r = p( o ); function o ( t, e ) { var n; return s( this, o ), y( l( n = r.call( this ) ), e ), n.opts = e, n.method = e.method || "GET", n.uri = t, n.async = !1 !== e.async, n.data = void 0 !== e.data ? e.data : null, n.create(), n } return a( o, [{ key: "create", value: function () { var e = this, t = M( this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref" ), n = ( t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs, this.xhr = new F( t ) ); try { n.open( this.method, this.uri, this.async ); try { if ( this.opts.extraHeaders ) for ( var r in n.setDisableHeaderCheck && n.setDisableHeaderCheck( !0 ), this.opts.extraHeaders ) this.opts.extraHeaders.hasOwnProperty( r ) && n.setRequestHeader( r, this.opts.extraHeaders[r] ) } catch ( t ) { } if ( "POST" === this.method ) try { n.setRequestHeader( "Content-type", "text/plain;charset=UTF-8" ) } catch ( t ) { } try { n.setRequestHeader( "Accept", "*/*" ) } catch ( t ) { } "withCredentials" in n && ( n.withCredentials = this.opts.withCredentials ), this.opts.requestTimeout && ( n.timeout = this.opts.requestTimeout ), n.onreadystatechange = function () { 4 === n.readyState && ( 200 === n.status || 1223 === n.status ? e.onLoad() : e.setTimeoutFn( function () { e.onError( "number" == typeof n.status ? n.status : 0 ) }, 0 ) ) }, n.send( this.data ) } catch ( t ) { return void this.setTimeoutFn( function () { e.onError( t ) }, 0 ) } "undefined" != typeof document && ( this.index = o.requestsCount++, o.requests[this.index] = this ) } }, { key: "onSuccess", value: function () { this.emit( "success" ), this.cleanup() } }, { key: "onData", value: function ( t ) { this.emit( "data", t ), this.onSuccess() } }, { key: "onError", value: function ( t ) { this.emit( "error", t ), this.cleanup( !0 ) } }, { key: "cleanup", value: function ( t ) { if ( void 0 !== this.xhr && null !== this.xhr ) { if ( this.xhr.onreadystatechange = ft, t ) try { this.xhr.abort() } catch ( t ) { } "undefined" != typeof document && delete o.requests[this.index], this.xhr = null } } }, { key: "onLoad", value: function () { var t = this.xhr.responseText; null !== t && this.onData( t ) } }, { key: "abort", value: function () { this.cleanup() } }] ), o }(); function pt () { for ( var t in B.requests ) B.requests.hasOwnProperty( t ) && B.requests[t].abort() } B.requestsCount = 0, B.requests = {}, "undefined" != typeof document && ( "function" == typeof attachEvent ? attachEvent( "onunload", pt ) : "function" == typeof addEventListener && ( T = "onpagehide" in o ? "pagehide" : "unload", addEventListener( T, pt, !1 ) ) ); var dt = "function" == typeof Promise && "function" == typeof Promise.resolve ? function ( t ) { return Promise.resolve().then( t ) } : function ( t, e ) { return e( t, 0 ) }, R = o.WebSocket || o.MozWebSocket, yt = "undefined" != typeof navigator && "string" == typeof navigator.product && "reactnative" === navigator.product.toLowerCase(), vt = { websocket: function () { h( r, it ); var n = p( r ); function r ( t ) { var e; return s( this, r ), ( e = n.call( this, t ) ).supportsBinary = !t.forceBase64, e } return a( r, [{ key: "name", get: function () { return "websocket" } }, { key: "doOpen", value: function () { if ( this.check() ) { var t = this.uri(), e = this.opts.protocols, n = yt ? {} : M( this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity" ); this.opts.extraHeaders && ( n.headers = this.opts.extraHeaders ); try { this.ws = yt ? new R( t, e, n ) : e ? new R( t, e ) : new R( t ) } catch ( t ) { return this.emit( "error", t ) } this.ws.binaryType = this.socket.binaryType || "arraybuffer", this.addEventListeners() } } }, { key: "addEventListeners", value: function () { var e = this; this.ws.onopen = function () { e.opts.autoUnref && e.ws._socket.unref(), e.onOpen() }, this.ws.onclose = this.onClose.bind( this ), this.ws.onmessage = function ( t ) { return e.onData( t.data ) }, this.ws.onerror = function ( t ) { return e.onError( "websocket error", t ) } } }, { key: "write", value: function ( r ) { for ( var o = this, t = ( this.writable = !1, 0 ); t < r.length; t++ )!function ( t ) { var e = r[t], n = t === r.length - 1; J( e, o.supportsBinary, function ( t ) { try { o.ws.send( t ) } catch ( t ) { } n && dt( function () { o.writable = !0, o.emit( "drain" ) }, o.setTimeoutFn ) } ) }( t ) } }, { key: "doClose", value: function () { void 0 !== this.ws && ( this.ws.close(), this.ws = null ) } }, { key: "uri", value: function () { var t = this.query || {}, e = this.opts.secure ? "wss" : "ws", n = "", t = ( this.opts.port && ( "wss" == e && 443 !== Number( this.opts.port ) || "ws" == e && 80 !== Number( this.opts.port ) ) && ( n = ":" + this.opts.port ), this.opts.timestampRequests && ( t[this.opts.timestampParam] = ut() ), this.supportsBinary || ( t.b64 = 1 ), E.encode( t ) ); return e + "://" + ( -1 !== this.opts.hostname.indexOf( ":" ) ? "[" + this.opts.hostname + "]" : this.opts.hostname ) + n + this.opts.path + ( t.length ? "?" + t : "" ) } }, { key: "check", value: function () { return !( !R || "__initialize" in R && this.name === r.prototype.name ) } }] ), r }(), polling: e }, mt = function () { h( f, v ); var r = p( f ); function f ( t ) { var e, n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}; return s( this, f ), e = r.call( this ), t && "object" === c( t ) && ( n = t, t = null ), t ? ( t = i( t ), n.hostname = t.host, n.secure = "https" === t.protocol || "wss" === t.protocol, n.port = t.port, t.query && ( n.query = t.query ) ) : n.host && ( n.hostname = i( n.host ).host ), y( l( e ), n ), e.secure = null != n.secure ? n.secure : "undefined" != typeof location && "https:" === location.protocol, n.hostname && !n.port && ( n.port = e.secure ? "443" : "80" ), e.hostname = n.hostname || ( "undefined" != typeof location ? location.hostname : "localhost" ), e.port = n.port || ( "undefined" != typeof location && location.port ? location.port : e.secure ? "443" : "80" ), e.transports = n.transports || ["polling", "websocket"], e.readyState = "", e.writeBuffer = [], e.prevBufferLen = 0, e.opts = u( { path: "/engine.io", agent: !1, withCredentials: !1, upgrade: !0, timestampParam: "t", rememberUpgrade: !1, rejectUnauthorized: !0, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: !0 }, n ), e.opts.path = e.opts.path.replace( /\/$/, "" ) + "/", "string" == typeof e.opts.query && ( e.opts.query = E.decode( e.opts.query ) ), e.id = null, e.upgrades = null, e.pingInterval = null, e.pingTimeout = null, e.pingTimeoutTimer = null, "function" == typeof addEventListener && ( e.opts.closeOnBeforeunload && addEventListener( "beforeunload", function () { e.transport && ( e.transport.removeAllListeners(), e.transport.close() ) }, !1 ), "localhost" !== e.hostname && ( e.offlineEventListener = function () { e.onClose( "transport close" ) }, addEventListener( "offline", e.offlineEventListener, !1 ) ) ), e.open(), e } return a( f, [{ key: "createTransport", value: function ( t ) { var e = function ( t ) { var e, n = {}; for ( e in t ) t.hasOwnProperty( e ) && ( n[e] = t[e] ); return n }( this.opts.query ), e = ( e.EIO = 4, e.transport = t, this.id && ( e.sid = this.id ), u( {}, this.opts.transportOptions[t], this.opts, { query: e, socket: this, hostname: this.hostname, secure: this.secure, port: this.port } ) ); return new vt[t]( e ) } }, { key: "open", value: function () { var t, e = this; if ( this.opts.rememberUpgrade && f.priorWebsocketSuccess && -1 !== this.transports.indexOf( "websocket" ) ) t = "websocket"; else { if ( 0 === this.transports.length ) return void this.setTimeoutFn( function () { e.emitReserved( "error", "No transports available" ) }, 0 ); t = this.transports[0] } this.readyState = "opening"; try { t = this.createTransport( t ) } catch ( t ) { return this.transports.shift(), void this.open() } t.open(), this.setTransport( t ) } }, { key: "setTransport", value: function ( t ) { var e = this; this.transport && this.transport.removeAllListeners(), ( this.transport = t ).on( "drain", this.onDrain.bind( this ) ).on( "packet", this.onPacket.bind( this ) ).on( "error", this.onError.bind( this ) ).on( "close", function () { e.onClose( "transport close" ) } ) } }, { key: "probe", value: function ( t ) { var e = this, n = this.createTransport( t ), r = !1, o = ( f.priorWebsocketSuccess = !1, function () { r || ( n.send( [{ type: "ping", data: "probe" }] ), n.once( "packet", function ( t ) { r || ( "pong" === t.type && "probe" === t.data ? ( e.upgrading = !0, e.emitReserved( "upgrading", n ), n && ( f.priorWebsocketSuccess = "websocket" === n.name, e.transport.pause( function () { r || "closed" !== e.readyState && ( h(), e.setTransport( n ), n.send( [{ type: "upgrade" }] ), e.emitReserved( "upgrade", n ), n = null, e.upgrading = !1, e.flush() ) } ) ) ) : ( ( t = new Error( "probe error" ) ).transport = n.name, e.emitReserved( "upgradeError", t ) ) ) } ) ) } ); function i () { r || ( r = !0, h(), n.close(), n = null ) } var s = function ( t ) { t = new Error( "probe error: " + t ); t.transport = n.name, i(), e.emitReserved( "upgradeError", t ) }; function a () { s( "transport closed" ) } function c () { s( "socket closed" ) } function u ( t ) { n && t.name !== n.name && i() } var h = function () { n.removeListener( "open", o ), n.removeListener( "error", s ), n.removeListener( "close", a ), e.off( "close", c ), e.off( "upgrading", u ) }; n.once( "open", o ), n.once( "error", s ), n.once( "close", a ), this.once( "close", c ), this.once( "upgrading", u ), n.open() } }, { key: "onOpen", value: function () { if ( this.readyState = "open", f.priorWebsocketSuccess = "websocket" === this.transport.name, this.emitReserved( "open" ), this.flush(), "open" === this.readyState && this.opts.upgrade && this.transport.pause ) for ( var t = 0, e = this.upgrades.length; t < e; t++ )this.probe( this.upgrades[t] ) } }, { key: "onPacket", value: function ( t ) { if ( "opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState ) switch ( this.emitReserved( "packet", t ), this.emitReserved( "heartbeat" ), t.type ) { case "open": this.onHandshake( JSON.parse( t.data ) ); break; case "ping": this.resetPingTimeout(), this.sendPacket( "pong" ), this.emitReserved( "ping" ), this.emitReserved( "pong" ); break; case "error": var e = new Error( "server error" ); e.code = t.data, this.onError( e ); break; case "message": this.emitReserved( "data", t.data ), this.emitReserved( "message", t.data ) } } }, { key: "onHandshake", value: function ( t ) { this.emitReserved( "handshake", t ), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades( t.upgrades ), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.onOpen(), "closed" !== this.readyState && this.resetPingTimeout() } }, { key: "resetPingTimeout", value: function () { var t = this; this.clearTimeoutFn( this.pingTimeoutTimer ), this.pingTimeoutTimer = this.setTimeoutFn( function () { t.onClose( "ping timeout" ) }, this.pingInterval + this.pingTimeout ), this.opts.autoUnref && this.pingTimeoutTimer.unref() } }, { key: "onDrain", value: function () { this.writeBuffer.splice( 0, this.prevBufferLen ), ( this.prevBufferLen = 0 ) === this.writeBuffer.length ? this.emitReserved( "drain" ) : this.flush() } }, { key: "flush", value: function () { "closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && ( this.transport.send( this.writeBuffer ), this.prevBufferLen = this.writeBuffer.length, this.emitReserved( "flush" ) ) } }, { key: "write", value: function ( t, e, n ) { return this.sendPacket( "message", t, e, n ), this } }, { key: "send", value: function ( t, e, n ) { return this.sendPacket( "message", t, e, n ), this } }, { key: "sendPacket", value: function ( t, e, n, r ) { "function" == typeof e && ( r = e, e = void 0 ), "function" == typeof n && ( r = n, n = null ), "closing" !== this.readyState && "closed" !== this.readyState && ( ( n = n || {} ).compress = !1 !== n.compress, this.emitReserved( "packetCreate", t = { type: t, data: e, options: n } ), this.writeBuffer.push( t ), r && this.once( "flush", r ), this.flush() ) } }, { key: "close", value: function () { function t () { n.off( "upgrade", t ), n.off( "upgradeError", t ), r() } function e () { n.once( "upgrade", t ), n.once( "upgradeError", t ) } var n = this, r = function () { n.onClose( "forced close" ), n.transport.close() }; return "opening" !== this.readyState && "open" !== this.readyState || ( this.readyState = "closing", this.writeBuffer.length ? this.once( "drain", function () { ( n.upgrading ? e : r )() } ) : ( this.upgrading ? e : r )() ), this } }, { key: "onError", value: function ( t ) { f.priorWebsocketSuccess = !1, this.emitReserved( "error", t ), this.onClose( "transport error", t ) } }, { key: "onClose", value: function ( t, e ) { "opening" !== this.readyState && "open" !== this.readyState && "closing" !== this.readyState || ( this.clearTimeoutFn( this.pingTimeoutTimer ), this.transport.removeAllListeners( "close" ), this.transport.close(), this.transport.removeAllListeners(), "function" == typeof removeEventListener && removeEventListener( "offline", this.offlineEventListener, !1 ), this.readyState = "closed", this.id = null, this.emitReserved( "close", t, e ), this.writeBuffer = [], this.prevBufferLen = 0 ) } }, { key: "filterUpgrades", value: function ( t ) { for ( var e = [], n = 0, r = t.length; n < r; n++ )~this.transports.indexOf( t[n] ) && e.push( t[n] ); return e } }] ), f }(); mt.protocol = 4; var gt = "function" == typeof ArrayBuffer, kt = function ( t ) { return "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView( t ) : t.buffer instanceof ArrayBuffer }, T = Object.prototype.toString, bt = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === T.call( Blob ), wt = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === T.call( File ); function O ( t ) { return gt && ( t instanceof ArrayBuffer || kt( t ) ) || bt && t instanceof Blob || wt && t instanceof File } function At ( t ) { var e = [], n = t.data; return t.data = function t ( e, n ) { if ( !e ) return e; { var r; { if ( O( e ) ) return r = { _placeholder: !0, num: n.length }, n.push( e ), r; if ( Array.isArray( e ) ) { for ( var o = new Array( e.length ), i = 0; i < e.length; i++ )o[i] = t( e[i], n ); return o } if ( "object" === c( e ) && !( e instanceof Date ) ) { var s, a = {}; for ( s in e ) e.hasOwnProperty( s ) && ( a[s] = t( e[s], n ) ); return a } } } return e }( n, e ), t.attachments = e.length, { packet: t, buffers: e } } function Ct ( t, e ) { return t.data = function t ( e, n ) { if ( !e ) return e; { if ( e && e._placeholder ) return n[e.num]; if ( Array.isArray( e ) ) for ( var r = 0; r < e.length; r++ )e[r] = t( e[r], n ); else if ( "object" === c( e ) ) for ( var o in e ) e.hasOwnProperty( o ) && ( e[o] = t( e[o], n ) ) } return e }( t.data, e ), t.attachments = void 0, t } ( e = S = S || {} )[e.CONNECT = 0] = "CONNECT", e[e.DISCONNECT = 1] = "DISCONNECT", e[e.EVENT = 2] = "EVENT", e[e.ACK = 3] = "ACK", e[e.CONNECT_ERROR = 4] = "CONNECT_ERROR", e[e.BINARY_EVENT = 5] = "BINARY_EVENT", e[e.BINARY_ACK = 6] = "BINARY_ACK"; var S, T = function () { function t () { s( this, t ) } return a( t, [{ key: "encode", value: function ( t ) { return t.type !== S.EVENT && t.type !== S.ACK || !function t ( e ) { if ( !e || "object" !== c( e ) ) return !1; if ( Array.isArray( e ) ) { for ( var n = 0, r = e.length; n < r; n++ )if ( t( e[n] ) ) return !0; return !1 } if ( O( e ) ) return !0; if ( e.toJSON && "function" == typeof e.toJSON && 1 === arguments.length ) return t( e.toJSON(), !0 ); for ( var o in e ) if ( Object.prototype.hasOwnProperty.call( e, o ) && t( e[o] ) ) return !0; return !1 }( t ) ? [this.encodeAsString( t )] : ( t.type = t.type === S.EVENT ? S.BINARY_EVENT : S.BINARY_ACK, this.encodeAsBinary( t ) ) } }, { key: "encodeAsString", value: function ( t ) { var e = "" + t.type; return t.type !== S.BINARY_EVENT && t.type !== S.BINARY_ACK || ( e += t.attachments + "-" ), t.nsp && "/" !== t.nsp && ( e += t.nsp + "," ), null != t.id && ( e += t.id ), null != t.data && ( e += JSON.stringify( t.data ) ), e } }, { key: "encodeAsBinary", value: function ( t ) { var t = At( t ), e = this.encodeAsString( t.packet ), t = t.buffers; return t.unshift( e ), t } }] ), t }(), e = function () { h( i, v ); var t = p( i ); function i () { return s( this, i ), t.call( this ) } return a( i, [{ key: "add", value: function ( t ) { var e; if ( "string" == typeof t ) ( e = this.decodeString( t ) ).type === S.BINARY_EVENT || e.type === S.BINARY_ACK ? ( this.reconstructor = new _t( e ), 0 === e.attachments && d( f( i.prototype ), "emitReserved", this ).call( this, "decoded", e ) ) : d( f( i.prototype ), "emitReserved", this ).call( this, "decoded", e ); else { if ( !O( t ) && !t.base64 ) throw new Error( "Unknown type: " + t ); if ( !this.reconstructor ) throw new Error( "got binary data when not reconstructing a packet" ); ( e = this.reconstructor.takeBinaryData( t ) ) && ( this.reconstructor = null, d( f( i.prototype ), "emitReserved", this ).call( this, "decoded", e ) ) } } }, { key: "decodeString", value: function ( t ) { var e = 0, n = { type: Number( t.charAt( 0 ) ) }; if ( void 0 === S[n.type] ) throw new Error( "unknown packet type " + n.type ); if ( n.type === S.BINARY_EVENT || n.type === S.BINARY_ACK ) { for ( var r = e + 1; "-" !== t.charAt( ++e ) && e != t.length; ); r = t.substring( r, e ); if ( r != Number( r ) || "-" !== t.charAt( e ) ) throw new Error( "Illegal attachments" ); n.attachments = Number( r ) } if ( "/" === t.charAt( e + 1 ) ) { for ( r = e + 1; ++e; ) { if ( "," === t.charAt( e ) ) break; if ( e === t.length ) break } n.nsp = t.substring( r, e ) } else n.nsp = "/"; r = t.charAt( e + 1 ); if ( "" !== r && Number( r ) == r ) { for ( r = e + 1; ++e; ) { var o = t.charAt( e ); if ( null == o || Number( o ) != o ) { --e; break } if ( e === t.length ) break } n.id = Number( t.substring( r, e + 1 ) ) } if ( t.charAt( ++e ) ) { r = function ( t ) { try { return JSON.parse( t ) } catch ( t ) { return !1 } }( t.substr( e ) ); if ( !i.isPayloadValid( n.type, r ) ) throw new Error( "invalid payload" ); n.data = r } return n } }, { key: "destroy", value: function () { this.reconstructor && this.reconstructor.finishedReconstruction() } }], [{ key: "isPayloadValid", value: function ( t, e ) { switch ( t ) { case S.CONNECT: return "object" === c( e ); case S.DISCONNECT: return void 0 === e; case S.CONNECT_ERROR: return "string" == typeof e || "object" === c( e ); case S.EVENT: case S.BINARY_EVENT: return Array.isArray( e ) && 0 < e.length; case S.ACK: case S.BINARY_ACK: return Array.isArray( e ) } } }] ), i }(); var _t = function () { function e ( t ) { s( this, e ), this.packet = t, this.buffers = [], this.reconPack = t } return a( e, [{ key: "takeBinaryData", value: function ( t ) { return this.buffers.push( t ), this.buffers.length === this.reconPack.attachments ? ( t = Ct( this.reconPack, this.buffers ), this.finishedReconstruction(), t ) : null } }, { key: "finishedReconstruction", value: function () { this.reconPack = null, this.buffers = [] } }] ), e }(), Et = Object.freeze( { __proto__: null, protocol: 5, get PacketType () { return S }, Encoder: T, Decoder: e } ); function N ( t, e, n ) { return t.on( e, n ), function () { t.off( e, n ) } } var Bt = Object.freeze( { connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 } ), Rt = function () { h( i, v ); var o = p( i ); function i ( t, e, n ) { var r; return s( this, i ), ( r = o.call( this ) ).connected = !1, r.disconnected = !0, r.receiveBuffer = [], r.sendBuffer = [], r.ids = 0, r.acks = {}, r.flags = {}, r.io = t, r.nsp = e, n && n.auth && ( r.auth = n.auth ), r.io._autoConnect && r.open(), r } return a( i, [{ key: "subEvents", value: function () { var t; this.subs || ( t = this.io, this.subs = [N( t, "open", this.onopen.bind( this ) ), N( t, "packet", this.onpacket.bind( this ) ), N( t, "error", this.onerror.bind( this ) ), N( t, "close", this.onclose.bind( this ) )] ) } }, { key: "active", get: function () { return !!this.subs } }, { key: "connect", value: function () { return this.connected || ( this.subEvents(), this.io._reconnecting || this.io.open(), "open" === this.io._readyState && this.onopen() ), this } }, { key: "open", value: function () { return this.connect() } }, { key: "send", value: function () { for ( var t = arguments.length, e = new Array( t ), n = 0; n < t; n++ )e[n] = arguments[n]; return e.unshift( "message" ), this.emit.apply( this, e ), this } }, { key: "emit", value: function ( t ) { if ( Bt.hasOwnProperty( t ) ) throw new Error( '"' + t + '" is a reserved event name' ); for ( var e = arguments.length, n = new Array( 1 < e ? e - 1 : 0 ), r = 1; r < e; r++ )n[r - 1] = arguments[r]; n.unshift( t ); var o, t = { type: S.EVENT, data: n, options: {} }, i = ( t.options.compress = !1 !== this.flags.compress, "function" == typeof n[n.length - 1] && ( o = this.ids++, i = n.pop(), this._registerAckCallback( o, i ), t.id = o ), this.io.engine && this.io.engine.transport && this.io.engine.transport.writable ); return this.flags.volatile && ( !i || !this.connected ) || ( this.connected ? this.packet( t ) : this.sendBuffer.push( t ) ), this.flags = {}, this } }, { key: "_registerAckCallback", value: function ( e, r ) { var o, i = this, t = this.flags.timeout; void 0 === t ? this.acks[e] = r : ( o = this.io.setTimeoutFn( function () { delete i.acks[e]; for ( var t = 0; t < i.sendBuffer.length; t++ )i.sendBuffer[t].id === e && i.sendBuffer.splice( t, 1 ); r.call( i, new Error( "operation has timed out" ) ) }, t ), this.acks[e] = function () { i.io.clearTimeoutFn( o ); for ( var t = arguments.length, e = new Array( t ), n = 0; n < t; n++ )e[n] = arguments[n]; r.apply( i, [null].concat( e ) ) } ) } }, { key: "packet", value: function ( t ) { t.nsp = this.nsp, this.io._packet( t ) } }, { key: "onopen", value: function () { var e = this; "function" == typeof this.auth ? this.auth( function ( t ) { e.packet( { type: S.CONNECT, data: t } ) } ) : this.packet( { type: S.CONNECT, data: this.auth } ) } }, { key: "onerror", value: function ( t ) { this.connected || this.emitReserved( "connect_error", t ) } }, { key: "onclose", value: function ( t ) { this.connected = !1, this.disconnected = !0, delete this.id, this.emitReserved( "disconnect", t ) } }, { key: "onpacket", value: function ( t ) { if ( t.nsp === this.nsp ) switch ( t.type ) { case S.CONNECT: t.data && t.data.sid ? ( e = t.data.sid, this.onconnect( e ) ) : this.emitReserved( "connect_error", new Error( "It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)" ) ); break; case S.EVENT: case S.BINARY_EVENT: this.onevent( t ); break; case S.ACK: case S.BINARY_ACK: this.onack( t ); break; case S.DISCONNECT: this.ondisconnect(); break; case S.CONNECT_ERROR: this.destroy(); var e = new Error( t.data.message ); e.data = t.data.data, this.emitReserved( "connect_error", e ) } } }, { key: "onevent", value: function ( t ) { var e = t.data || []; null != t.id && e.push( this.ack( t.id ) ), this.connected ? this.emitEvent( e ) : this.receiveBuffer.push( Object.freeze( e ) ) } }, { key: "emitEvent", value: function ( t ) { if ( this._anyListeners && this._anyListeners.length ) { var e, n = q( this._anyListeners.slice() ); try { for ( n.s(); !( e = n.n() ).done; )e.value.apply( this, t ) } catch ( t ) { n.e( t ) } finally { n.f() } } d( f( i.prototype ), "emit", this ).apply( this, t ) } }, { key: "ack", value: function ( r ) { var o = this, i = !1; return function () { if ( !i ) { i = !0; for ( var t = arguments.length, e = new Array( t ), n = 0; n < t; n++ )e[n] = arguments[n]; o.packet( { type: S.ACK, id: r, data: e } ) } } } }, { key: "onack", value: function ( t ) { var e = this.acks[t.id]; "function" == typeof e && ( e.apply( this, t.data ), delete this.acks[t.id] ) } }, { key: "onconnect", value: function ( t ) { this.id = t, this.connected = !0, this.disconnected = !1, this.emitBuffered(), this.emitReserved( "connect" ) } }, { key: "emitBuffered", value: function () { var e = this; this.receiveBuffer.forEach( function ( t ) { return e.emitEvent( t ) } ), this.receiveBuffer = [], this.sendBuffer.forEach( function ( t ) { return e.packet( t ) } ), this.sendBuffer = [] } }, { key: "ondisconnect", value: function () { this.destroy(), this.onclose( "io server disconnect" ) } }, { key: "destroy", value: function () { this.subs && ( this.subs.forEach( function ( t ) { return t() } ), this.subs = void 0 ), this.io._destroy( this ) } }, { key: "disconnect", value: function () { return this.connected && this.packet( { type: S.DISCONNECT } ), this.destroy(), this.connected && this.onclose( "io client disconnect" ), this } }, { key: "close", value: function () { return this.disconnect() } }, { key: "compress", value: function ( t ) { return this.flags.compress = t, this } }, { key: "volatile", get: function () { return this.flags.volatile = !0, this } }, { key: "timeout", value: function ( t ) { return this.flags.timeout = t, this } }, { key: "onAny", value: function ( t ) { return this._anyListeners = this._anyListeners || [], this._anyListeners.push( t ), this } }, { key: "prependAny", value: function ( t ) { return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift( t ), this } }, { key: "offAny", value: function ( t ) { if ( !this._anyListeners ) return this; if ( t ) { for ( var e = this._anyListeners, n = 0; n < e.length; n++ )if ( t === e[n] ) return e.splice( n, 1 ), this } else this._anyListeners = []; return this } }, { key: "listenersAny", value: function () { return this._anyListeners || [] } }] ), i }(), Tt = x; function x ( t ) { this.ms = ( t = t || {} ).min || 100, this.max = t.max || 1e4, this.factor = t.factor || 2, this.jitter = 0 < t.jitter && t.jitter <= 1 ? t.jitter : 0, this.attempts = 0 } x.prototype.duration = function () { var t, e, n = this.ms * Math.pow( this.factor, this.attempts++ ); return this.jitter && ( t = Math.random(), e = Math.floor( t * this.jitter * n ), n = 0 == ( 1 & Math.floor( 10 * t ) ) ? n - e : n + e ), 0 | Math.min( n, this.max ) }, x.prototype.reset = function () { this.attempts = 0 }, x.prototype.setMin = function ( t ) { this.ms = t }, x.prototype.setMax = function ( t ) { this.max = t }, x.prototype.setJitter = function ( t ) { this.jitter = t }; var L = function () { h( i, v ); var o = p( i ); function i ( t, e ) { s( this, i ), ( n = o.call( this ) ).nsps = {}, n.subs = [], t && "object" === c( t ) && ( e = t, t = void 0 ), ( e = e || {} ).path = e.path || "/socket.io", n.opts = e, y( l( n ), e ), n.reconnection( !1 !== e.reconnection ), n.reconnectionAttempts( e.reconnectionAttempts || 1 / 0 ), n.reconnectionDelay( e.reconnectionDelay || 1e3 ), n.reconnectionDelayMax( e.reconnectionDelayMax || 5e3 ), n.randomizationFactor( null != ( r = e.randomizationFactor ) ? r : .5 ), n.backoff = new Tt( { min: n.reconnectionDelay(), max: n.reconnectionDelayMax(), jitter: n.randomizationFactor() } ), n.timeout( null == e.timeout ? 2e4 : e.timeout ), n._readyState = "closed", n.uri = t; var n, r = e.parser || Et; return n.encoder = new r.Encoder, n.decoder = new r.Decoder, n._autoConnect = !1 !== e.autoConnect, n._autoConnect && n.open(), n } return a( i, [{ key: "reconnection", value: function ( t ) { return arguments.length ? ( this._reconnection = !!t, this ) : this._reconnection } }, { key: "reconnectionAttempts", value: function ( t ) { return void 0 === t ? this._reconnectionAttempts : ( this._reconnectionAttempts = t, this ) } }, { key: "reconnectionDelay", value: function ( t ) { var e; return void 0 === t ? this._reconnectionDelay : ( this._reconnectionDelay = t, null != ( e = this.backoff ) && e.setMin( t ), this ) } }, { key: "randomizationFactor", value: function ( t ) { var e; return void 0 === t ? this._randomizationFactor : ( this._randomizationFactor = t, null != ( e = this.backoff ) && e.setJitter( t ), this ) } }, { key: "reconnectionDelayMax", value: function ( t ) { var e; return void 0 === t ? this._reconnectionDelayMax : ( this._reconnectionDelayMax = t, null != ( e = this.backoff ) && e.setMax( t ), this ) } }, { key: "timeout", value: function ( t ) { return arguments.length ? ( this._timeout = t, this ) : this._timeout } }, { key: "maybeReconnectOnOpen", value: function () { !this._reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect() } }, { key: "open", value: function ( e ) { var n = this; if ( ~this._readyState.indexOf( "open" ) ) return this; this.engine = new mt( this.uri, this.opts ); var t, r, o = this.engine, i = this, s = ( this._readyState = "opening", this.skipReconnect = !1, N( o, "open", function () { i.onopen(), e && e() } ) ), a = N( o, "error", function ( t ) { i.cleanup(), i._readyState = "closed", n.emitReserved( "error", t ), e ? e( t ) : i.maybeReconnectOnOpen() } ); return !1 !== this._timeout && ( 0 === ( t = this._timeout ) && s(), r = this.setTimeoutFn( function () { s(), o.close(), o.emit( "error", new Error( "timeout" ) ) }, t ), this.opts.autoUnref && r.unref(), this.subs.push( function () { clearTimeout( r ) } ) ), this.subs.push( s ), this.subs.push( a ), this } }, { key: "connect", value: function ( t ) { return this.open( t ) } }, { key: "onopen", value: function () { this.cleanup(), this._readyState = "open", this.emitReserved( "open" ); var t = this.engine; this.subs.push( N( t, "ping", this.onping.bind( this ) ), N( t, "data", this.ondata.bind( this ) ), N( t, "error", this.onerror.bind( this ) ), N( t, "close", this.onclose.bind( this ) ), N( this.decoder, "decoded", this.ondecoded.bind( this ) ) ) } }, { key: "onping", value: function () { this.emitReserved( "ping" ) } }, { key: "ondata", value: function ( t ) { this.decoder.add( t ) } }, { key: "ondecoded", value: function ( t ) { this.emitReserved( "packet", t ) } }, { key: "onerror", value: function ( t ) { this.emitReserved( "error", t ) } }, { key: "socket", value: function ( t, e ) { var n; return ( n = this.nsps[t] ) || ( n = new Rt( this, t, e ), this.nsps[t] = n ), n } }, { key: "_destroy", value: function ( t ) { for ( var e = 0, n = Object.keys( this.nsps ); e < n.length; e++ ) { var r = n[e]; if ( this.nsps[r].active ) return } this._close() } }, { key: "_packet", value: function ( t ) { for ( var e = this.encoder.encode( t ), n = 0; n < e.length; n++ )this.engine.write( e[n], t.options ) } }, { key: "cleanup", value: function () { this.subs.forEach( function ( t ) { return t() } ), this.subs.length = 0, this.decoder.destroy() } }, { key: "_close", value: function () { this.skipReconnect = !0, this._reconnecting = !1, this.onclose( "forced close" ), this.engine && this.engine.close() } }, { key: "disconnect", value: function () { return this._close() } }, { key: "onclose", value: function ( t ) { this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved( "close", t ), this._reconnection && !this.skipReconnect && this.reconnect() } }, { key: "reconnect", value: function () { var e = this; if ( this._reconnecting || this.skipReconnect ) return this; var t, n, r = this; this.backoff.attempts >= this._reconnectionAttempts ? ( this.backoff.reset(), this.emitReserved( "reconnect_failed" ), this._reconnecting = !1 ) : ( t = this.backoff.duration(), this._reconnecting = !0, n = this.setTimeoutFn( function () { r.skipReconnect || ( e.emitReserved( "reconnect_attempt", r.backoff.attempts ), r.skipReconnect || r.open( function ( t ) { t ? ( r._reconnecting = !1, r.reconnect(), e.emitReserved( "reconnect_error", t ) ) : r.onreconnect() } ) ) }, t ), this.opts.autoUnref && n.unref(), this.subs.push( function () { clearTimeout( n ) } ) ) } }, { key: "onreconnect", value: function () { var t = this.backoff.attempts; this._reconnecting = !1, this.backoff.reset(), this.emitReserved( "reconnect", t ) } }] ), i }(), j = {}; function P ( t, e ) { "object" === c( t ) && ( e = t, t = void 0 ); var t = function ( t, e, n ) { var e = 1 < arguments.length && void 0 !== e ? e : "", r = t, n = ( 2 < arguments.length ? n : void 0 ) || "undefined" != typeof location && location; return "string" == typeof ( t = null == t ? n.protocol + "//" + n.host : t ) && ( "/" === t.charAt( 0 ) && ( t = "/" === t.charAt( 1 ) ? n.protocol + t : n.host + t ), /^(https?|wss?):\/\//.test( t ) || ( t = void 0 !== n ? n.protocol + "//" + t : "https://" + t ), r = i( t ) ), r.port || ( /^(http|ws)$/.test( r.protocol ) ? r.port = "80" : /^(http|ws)s$/.test( r.protocol ) && ( r.port = "443" ) ), r.path = r.path || "/", t = -1 !== r.host.indexOf( ":" ) ? "[" + r.host + "]" : r.host, r.id = r.protocol + "://" + t + ":" + r.port + e, r.href = r.protocol + "://" + t + ( n && n.port === r.port ? "" : ":" + r.port ), r }( t, ( e = e || {} ).path || "/socket.io" ), n = t.source, r = t.id, o = t.path, o = j[r] && o in j[r].nsps, o = e.forceNew || e["force new connection"] || !1 === e.multiplex || o ? new L( n, e ) : ( j[r] || ( j[r] = new L( n, e ) ), j[r] ); return t.query && !e.query && ( e.query = t.queryKey ), o.socket( t.path, e ) } return u( P, { Manager: L, Socket: Rt, io: P, connect: P } ), P } ); "use strict"; window.CHUB = function () { var e = this; this.socket = {}, CHUB.prototype.start = function ( t ) { t ? ( this.socket = io( "https://notify.telecmi.com", { query: { token: t } } ), this.socket.on( "agents-list", function ( t ) { e.onAgents( t ) } ), this.socket.on( "call-feed", function ( t ) { e.onCalls( t ) } ), this.socket.on( "connect", () => { var t = this.socket.inetno; this.socket.feed && this.socket.emit( "admin-get-feed", { inetno: t } ), this.socket.agent && this.socket.emit( "subscribeadmin-agents-list", { inetno: t } ) } ), this.socket.on( "disconnect", () => { } ), this.socket.on( "callback-list", function ( t ) { e.onCallback( t ) } ), this.socket.on( "cmi-status", function ( t ) { e.onStatus( t ) } ), this.socket.on( "live-call-feed", function ( t ) { e.onCount( t ) } ), this.socket.on( "agent-bridged", function ( t ) { e.onagentAnswer( t ) } ), this.socket.on( "customer-bridged", function ( t ) { e.onAnswer( t ) } ) ) : this.onStatus( { status: "error", msg: "Invalid token" } ) }, CHUB.prototype.subscribeAgents = function ( t ) { this.socket.agent = !0, this.socket.inetno = t, this.socket.emit( "subscribeadmin-agents-list", { inetno: t } ) }, CHUB.prototype.removeAllListeners = function ( t ) { this.socket.removeAllListeners() }, CHUB.prototype.callBarging = function ( t, e, n ) { t ? this.socket.emit( "admin-call-barging", { uuid: t, to: e, myid: n } ) : this.onStatus( { status: "error", msg: "Invalid UUID" } ) }, CHUB.prototype.globalBarging = function ( t, e ) { t ? this.socket.emit( "admin-call-globalbarging", { uuid: t, to: e } ) : this.onStatus( { status: "error", msg: "Invalid UUID" } ) }, CHUB.prototype.subscribeCalls = function ( t ) { this.socket.emit( "admin-get-feed", { inetno: t } ), this.socket.feed = !0, this.socket.inetno = t }, CHUB.prototype.monitorCalls = function ( t ) { t ? this.socket.emit( "admin-call-feed", { inetno: t } ) : this.onStatus( { status: "error", msg: "Invalid APP ID" } ) }, CHUB.prototype.onCalls = function ( t ) { }, CHUB.prototype.onAgents = function ( t ) { }, CHUB.prototype.onStatus = function ( t ) { }, CHUB.prototype.onCount = function ( t ) { }, CHUB.prototype.onagentAnswer = function ( t ) { }, CHUB.prototype.onAnswer = function ( t ) { }, CHUB.prototype.onCallback = function ( t ) { } };